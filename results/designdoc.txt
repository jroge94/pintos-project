Design Document
Process controls

Data structures and functions

/* Structure to represent child processes. */
struct child_process {
    tid_t tid;                   // Thread ID of the child.
    int exit_status;             // Exit status of the child.
    bool wait_istrue;            // Whether wait() has been called on this child.
    struct semaphore sema_wait;  // Semaphore for parent to wait on child.
    struct list_elem elem;       // List element for child list.
};

This structure holds information about child processes, and helps facilitate synchronization and the status of a child process.

/* Modifying struct thread in thread.h */
struct list child_list;          // List of child processes.
struct child_process *cp;        // Pointer to own child_process struct.
struct semaphore sema_exec;      // Semaphore for synchronization during exec
struct semaphore sema_exit;      // Semaphore for synchronization during exit
bool load_success;               // Checks if process has loaded succesfully

Functions

bool validate_user_pointer(const void *ptr);
// Checks if user pointer is valid
bool copy_in(void *dst, const void *usrc, size_t size)
// Safely copying data from user to kernel space
bool copy_out(void *udst, const void *src, size_t size)
// Safely copying data from kernel space to user space

Algorithms 

Accessing user memory Safely

1. We first would use validate_user_pointer to ensure the pointer is valid.
2. We use copy_in() and copy_out() to transfer data between user and kernel

Implementaiton of system calls

Inside of syscall_handler function in syscalls.c
  
Implementation of practice syscall

1. Retrieve system call argument from user stack
2. Validate user pointer with validate_user_pointer function
3. Safely copy the integer argument into kernel space from user space
4. Call the syscall implementation and set return value
    - f->eax = i + 1

Implementation of halt syscall
1. if args[0] = SYS_HALT
2. call function shutdown_power_off()

Implementation of wait sys call
Parent process
1. Retrieve and validate PID argument from user stack.
1. Traverse child_list to find the child_process with given PID.
2. Check if child is already waited on, if it is return -1 to prevent multiple waits.
We also need to check here if the PID corresponds to a direct child or not, if it does not wait() should return -1.
We also need to make sure that if the child did not call exit() and was instead terminated by the kernel, wait() should return -1.
3. If not, set wait_istrue to true and call sema_down(&child->sema_wait) to block until child signals termination.
4. After unblocking, get exit status of child and remove it from child_list. Free its memory.
5. Return exit status to user program
Child process on exit
1. In process_exit(), set cp->exit_status to the process's exit status.
2. Call sema_up(&cp->sema_wait) to unblock any waiting parent 
3. Cleanup resources

Implementation of exec System Call

Parent process
1. Initialize synchronization
  - Initialize sema_init and thread_current->load_success = false
2. Execute process_execute to create the child process
3. Call sema_down to wait for child to signal
4. Check load success with load_success is true/false
5. If load_success is true, return the child's PID, else return -1

In Child process
1. Attempt to load exec
2. Set load status to true if succesfull and false if unsuccesfull.
3. Signal parent to unblock if successful with sema_up

Implementation of exit system call

1. Get exit status argument from user stack
2. Validate pointer and copy the exit status with copy_in()
3. Set the current threads exit status to the retrieved exit status and print exit message
4. Signal possible waiting parent process using sema_up
5. Close files and call thread_exit to terminate the process.

Synchronization

1. struct child_process
    - Accessed by both parent and child processes
        The parent process initializes a child_process struct for each child and adds it to child_list
        The child process has a pointer to its own child_process struct which it updates when exiting
    - Synchronization
        We use semaphores like sema_wait and sema_exit within child_process struct to make sure the parent and child are not
        modifying the same data concurrently as well as avoiding race conditions.
        The parent process modifies the child_process struct when creating and removing it from child_list after wait().
        The child process updates its exit_status and signals the parents when it exits.
2. child_list in struct thread
    -Accesed by the parent process
        The parent will add new child_process structs to the child_list when its creating child processes.
        It will also remove child_process structs from child_list after calling wait() or when exiting
    - Synchronization
        Only the parent thead modifies its own child_list, so no other thread can access it. This also avoids race conditions.
3. semaphores
    - Accesed by both parent and child processes
        sema_exec - Parent initializes and waits after calling process_execute(), the child signals it after attempting to load executable.
        sema_wait- Parent waits on it durin wait() until the child exits, and the child signals upon exiting.
        sema_exit - Child waits on it after signaling the parent when exiting, and parent signals it after it retrieves the child's exit status.
    - Synchronization
    - Using semaphores enforces the parent and child to have a strict order of operations it must go through to ensure synchronization, which if done correctly
    will ensure that the threads wait for the necessary signals before proceeding.
4. load_success 
    - Accesed by both parent and child processes
        Child process sets it to true or false depending on if loading the executable worked. The parent process reads load_success after being signaled by child.
    - Synchronization
        The parent will wait on sema_exec and only until after the child signals will it read load_success.
5. exit_status 
    - Accessed by both child and parent processes
        The child process will write the exit status upon exiting, and the parent process will read the status after its signaled by the child.
    - Synchronization
        The parent will wait on sema_wait and only read the exit status until after the child has signaled to the parent process.
        
Rationale

This design aims to provide a clear and efficient implenetation of the required functionalities for processs control. We use simple data structures like struct child_process 
to make it easy to manage child-specific information and synchronization. We also utilize clear synchronization mechanisms with the use of sema_wait, sema_exec, and sema_exit to synchronize between parent
and child processes.

We tried to add reusability into our code, for functions like validate_user_pointer and copy_in and copy_out. These are functions designed to reuse for multiple system calls we 
will implement in this part of the project. This also would allow for us to easily add more system calls if we needed, as we can call these functions in them to accomplish tasks
we would have had to complete. We also do not add much overhead for the time complexity of the programs as semaphores are only used so often and they do not seriously
impact performance.


